import { useState } from 'react';
import { OverlayElement } from './PosterPreview';
import styles from './OverlayCodeView.module.css';

export interface OverlayCodeViewProps {
  elements: OverlayElement[];
  onElementsChange: (elements: OverlayElement[]) => void;
}

export function OverlayCodeView({ elements, onElementsChange }: OverlayCodeViewProps) {
  const [codeError, setCodeError] = useState<string | null>(null);

  // Generate Kometa-compatible YAML representation of overlay config
  const generateCode = (): string => {
    if (elements.length === 0) {
      return '# No overlay elements defined\n# Add overlays using the visual editor\noverlay_files: []';
    }

    const lines = ['# Kometa Overlay Configuration'];
    lines.push('# Generated by Kometa Studio');
    lines.push('');
    lines.push('overlays:');

    elements.forEach((element, index) => {
      const content = element.text || element.content || '';
      const elementType =
        element.type === 'badge' ? 'badge' : element.type === 'ribbon' ? 'text' : element.type;

      lines.push('');
      lines.push(`  overlay_${index + 1}:`);
      lines.push(`    # ${elementType.toUpperCase()}: ${content || 'No content'}`);

      // Use Kometa's position system (horizontal/vertical with offsets)
      if (element.position) {
        if (element.position.horizontal) {
          lines.push(`    horizontal_align: ${element.position.horizontal}`);
        }
        if (element.position.vertical) {
          lines.push(`    vertical_align: ${element.position.vertical}`);
        }
      }

      // Offsets
      if (element.offset) {
        if (element.offset.horizontal !== undefined) {
          lines.push(`    horizontal_offset: ${element.offset.horizontal}`);
        }
        if (element.offset.vertical !== undefined) {
          lines.push(`    vertical_offset: ${element.offset.vertical}`);
        }
      }

      // Content
      if (content) {
        lines.push(`    text: "${content}"`);
      }

      // Kometa back_width and back_height (for badges)
      if (element.width !== undefined) {
        lines.push(`    back_width: ${element.width}`);
      }
      if (element.height !== undefined) {
        lines.push(`    back_height: ${element.height}`);
      }

      // Font styling
      if (element.fontSize !== undefined) {
        lines.push(`    font_size: ${element.fontSize}`);
      }
      if (element.fontColor !== undefined) {
        lines.push(`    font_color: "${element.fontColor}"`);
      }

      // Background styling (Kometa uses back_color)
      if (element.backgroundColor !== undefined) {
        lines.push(`    back_color: "${element.backgroundColor}"`);
      }
      if (element.borderRadius !== undefined && element.borderRadius > 0) {
        lines.push(`    back_radius: ${element.borderRadius}`);
      }
      if (element.padding !== undefined && element.padding > 0) {
        lines.push(`    back_padding: ${element.padding}`);
      }

      // Addon image (for rating logos)
      if (element.addonImage) {
        lines.push(`    # Rating logo from: ${element.addonImage.split('/').pop()}`);
        lines.push(`    addon_position: ${element.addonPosition || 'left'}`);
        lines.push(`    addon_offset: ${element.addonOffset || 15}`);
      }

      // Image URL (for image overlays)
      if (element.imageUrl !== undefined) {
        lines.push(`    file: "${element.imageUrl}"`);
      }

      // Rotation
      if (element.rotation !== undefined && element.rotation !== 0) {
        lines.push(`    angle: ${element.rotation}`);
      }
    });

    return lines.join('\n');
  };

  const [code, setCode] = useState(generateCode());

  // Update code when elements change externally
  const handleCodeChange = (newCode: string) => {
    setCode(newCode);
    setCodeError(null);

    // Try to parse the code and update elements
    try {
      // This is a simplified parser - in a real implementation, you'd use a proper YAML parser
      // For now, we'll just keep the code in sync visually
      // TODO: Implement proper YAML parsing if needed
    } catch (error) {
      setCodeError(error instanceof Error ? error.message : 'Invalid format');
    }
  };

  // Regenerate code when elements prop changes
  const currentCode = generateCode();
  if (currentCode !== code && !codeError) {
    setCode(currentCode);
  }

  const handleCopyCode = () => {
    navigator.clipboard.writeText(code);
    alert('Code copied to clipboard!');
  };

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <h3 className={styles.title}>Overlay Configuration Code</h3>
        <button onClick={handleCopyCode} className={styles.copyButton}>
          Copy
        </button>
      </div>

      {codeError && <div className={styles.error}>Error: {codeError}</div>}

      <textarea
        value={code}
        onChange={(e) => handleCodeChange(e.target.value)}
        className={styles.codeEditor}
        spellCheck={false}
        placeholder="# Overlay configuration will appear here"
      />

      <div className={styles.info}>
        <p>
          This represents your overlay configuration in YAML format. Changes made in the visual
          editor are automatically reflected here.
        </p>
      </div>
    </div>
  );
}
