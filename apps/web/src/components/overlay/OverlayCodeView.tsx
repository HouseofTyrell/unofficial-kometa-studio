import { useState, useEffect, useCallback } from 'react';
import * as yaml from 'js-yaml';
import { OverlayElement } from './PosterPreview';
import styles from './OverlayCodeView.module.css';

export interface OverlayCodeViewProps {
  elements: OverlayElement[];
  onElementsChange: (elements: OverlayElement[]) => void;
}

// Parse YAML overlays back to OverlayElement array
function parseYamlToElements(yamlContent: string): OverlayElement[] {
  const parsed = yaml.load(yamlContent) as any;

  if (!parsed || !parsed.overlays) {
    return [];
  }

  const elements: OverlayElement[] = [];

  for (const [_name, overlayDef] of Object.entries(parsed.overlays)) {
    const def = overlayDef as any;

    // Determine element type based on properties
    let type: OverlayElement['type'] = 'badge';
    if (def.file || def.url || def.git) {
      type = 'image';
    } else if (def.back_width && def.back_width >= 400) {
      type = 'ribbon';
    }

    // Map Kometa properties to OverlayElement
    const element: OverlayElement = {
      type,
      content: def.text || '',
      text: def.text || '',
    };

    // Position
    if (def.horizontal_align || def.vertical_align) {
      element.position = {
        horizontal: def.horizontal_align || 'left',
        vertical: def.vertical_align || 'top',
      };
    }

    // Offsets
    if (def.horizontal_offset !== undefined || def.vertical_offset !== undefined) {
      element.offset = {
        horizontal: def.horizontal_offset || 0,
        vertical: def.vertical_offset || 0,
      };
    }

    // Dimensions
    if (def.back_width !== undefined) {
      element.width = def.back_width;
    }
    if (def.back_height !== undefined) {
      element.height = def.back_height;
    }

    // Font styling
    if (def.font_size !== undefined) {
      element.fontSize = def.font_size;
    }
    if (def.font_color !== undefined) {
      element.fontColor = def.font_color;
    }

    // Background styling
    if (def.back_color !== undefined) {
      element.backgroundColor = def.back_color;
    }
    if (def.back_radius !== undefined) {
      element.borderRadius = def.back_radius;
    }
    if (def.back_padding !== undefined) {
      element.padding = def.back_padding;
    }

    // Image URL
    if (def.file) {
      element.imageUrl = def.file;
    } else if (def.url) {
      element.imageUrl = def.url;
    }

    // Rotation
    if (def.angle !== undefined) {
      element.rotation = def.angle;
    }

    // Addon (for ratings)
    if (def.addon_position) {
      element.addonPosition = def.addon_position;
    }
    if (def.addon_offset !== undefined) {
      element.addonOffset = def.addon_offset;
    }

    elements.push(element);
  }

  return elements;
}

export function OverlayCodeView({ elements, onElementsChange }: OverlayCodeViewProps) {
  const [codeError, setCodeError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [editedCode, setEditedCode] = useState('');

  // Generate Kometa-compatible YAML representation of overlay config
  const generateCode = useCallback((): string => {
    if (elements.length === 0) {
      return '# No overlay elements defined\n# Add overlays using the visual editor\noverlays: {}';
    }

    const lines = ['# Kometa Overlay Configuration'];
    lines.push('# Generated by Kometa Studio');
    lines.push('# Edit below and click "Apply Changes" to update the visual editor');
    lines.push('');
    lines.push('overlays:');

    elements.forEach((element, index) => {
      const content = element.text || element.content || '';
      const elementType =
        element.type === 'badge' ? 'badge' : element.type === 'ribbon' ? 'text' : element.type;

      lines.push('');
      lines.push(`  overlay_${index + 1}:`);
      lines.push(`    # ${elementType.toUpperCase()}: ${content || 'No content'}`);

      // Use Kometa's position system (horizontal/vertical with offsets)
      if (element.position) {
        if (element.position.horizontal) {
          lines.push(`    horizontal_align: ${element.position.horizontal}`);
        }
        if (element.position.vertical) {
          lines.push(`    vertical_align: ${element.position.vertical}`);
        }
      }

      // Offsets
      if (element.offset) {
        if (element.offset.horizontal !== undefined) {
          lines.push(`    horizontal_offset: ${element.offset.horizontal}`);
        }
        if (element.offset.vertical !== undefined) {
          lines.push(`    vertical_offset: ${element.offset.vertical}`);
        }
      }

      // Content
      if (content) {
        lines.push(`    text: "${content}"`);
      }

      // Kometa back_width and back_height (for badges)
      if (element.width !== undefined) {
        lines.push(`    back_width: ${element.width}`);
      }
      if (element.height !== undefined) {
        lines.push(`    back_height: ${element.height}`);
      }

      // Font styling
      if (element.fontSize !== undefined) {
        lines.push(`    font_size: ${element.fontSize}`);
      }
      if (element.fontColor !== undefined) {
        lines.push(`    font_color: "${element.fontColor}"`);
      }

      // Background styling (Kometa uses back_color)
      if (element.backgroundColor !== undefined) {
        lines.push(`    back_color: "${element.backgroundColor}"`);
      }
      if (element.borderRadius !== undefined && element.borderRadius > 0) {
        lines.push(`    back_radius: ${element.borderRadius}`);
      }
      if (element.padding !== undefined && element.padding > 0) {
        lines.push(`    back_padding: ${element.padding}`);
      }

      // Addon image (for rating logos)
      if (element.addonImage) {
        lines.push(`    # Rating logo from: ${element.addonImage.split('/').pop()}`);
        lines.push(`    addon_position: ${element.addonPosition || 'left'}`);
        lines.push(`    addon_offset: ${element.addonOffset || 15}`);
      }

      // Image URL (for image overlays)
      if (element.imageUrl !== undefined) {
        lines.push(`    file: "${element.imageUrl}"`);
      }

      // Rotation
      if (element.rotation !== undefined && element.rotation !== 0) {
        lines.push(`    angle: ${element.rotation}`);
      }
    });

    return lines.join('\n');
  }, [elements]);

  // Initialize edited code when elements change (but not during editing)
  useEffect(() => {
    if (!isEditing) {
      setEditedCode(generateCode());
      setCodeError(null);
    }
  }, [elements, generateCode, isEditing]);

  // Handle code changes in textarea
  const handleCodeChange = (newCode: string) => {
    setEditedCode(newCode);
    setIsEditing(true);

    // Validate YAML as user types
    try {
      yaml.load(newCode);
      setCodeError(null);
    } catch (error) {
      if (error instanceof yaml.YAMLException) {
        setCodeError(`YAML Error: ${error.message}`);
      }
    }
  };

  // Apply changes from code to visual editor
  const handleApplyChanges = () => {
    try {
      const newElements = parseYamlToElements(editedCode);
      onElementsChange(newElements);
      setCodeError(null);
      setIsEditing(false);
    } catch (error) {
      setCodeError(
        error instanceof Error ? `Parse Error: ${error.message}` : 'Failed to parse YAML'
      );
    }
  };

  // Discard changes and reset to current elements
  const handleDiscardChanges = () => {
    setEditedCode(generateCode());
    setCodeError(null);
    setIsEditing(false);
  };

  const handleCopyCode = () => {
    navigator.clipboard.writeText(editedCode);
  };

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <h3 className={styles.title}>Overlay Configuration Code</h3>
        <div className={styles.actions}>
          {isEditing && (
            <>
              <button
                onClick={handleApplyChanges}
                className={styles.applyButton}
                disabled={!!codeError}
                title={codeError ? 'Fix YAML errors first' : 'Apply changes to visual editor'}
              >
                Apply Changes
              </button>
              <button
                onClick={handleDiscardChanges}
                className={styles.discardButton}
                title="Discard changes"
              >
                Discard
              </button>
            </>
          )}
          <button onClick={handleCopyCode} className={styles.copyButton}>
            Copy
          </button>
        </div>
      </div>

      {codeError && <div className={styles.error}>{codeError}</div>}

      {isEditing && !codeError && (
        <div className={styles.editingIndicator}>Editing - changes not yet applied</div>
      )}

      <textarea
        value={editedCode}
        onChange={(e) => handleCodeChange(e.target.value)}
        className={`${styles.codeEditor} ${isEditing ? styles.editing : ''} ${codeError ? styles.hasError : ''}`}
        spellCheck={false}
        placeholder="# Overlay configuration will appear here"
      />

      <div className={styles.info}>
        <p>
          Edit the YAML above and click <strong>Apply Changes</strong> to update the visual editor.
          Changes are validated in real-time.
        </p>
      </div>
    </div>
  );
}
